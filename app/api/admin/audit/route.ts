import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/auth';
import { getAuditLogs } from '@/lib/audit-log';
import PDFDocument from 'pdfkit';

export async function GET(request: NextRequest) {
  try {
    const session = await auth();
    
    if (!session?.user || session.user.role !== 'admin') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const isExport = searchParams.get('export') === 'true';
    const format = searchParams.get('format') || 'json';
    
    // For export, get all logs without pagination
    const page = isExport ? 1 : parseInt(searchParams.get('page') || '1');
    const limit = isExport ? 10000 : parseInt(searchParams.get('limit') || '50');
    const userId = searchParams.get('userId') || undefined;
    const action = searchParams.get('action') || undefined;
    const resource = searchParams.get('resource') || undefined;
    const startDate = searchParams.get('startDate') ? new Date(searchParams.get('startDate')!) : undefined;
    const endDate = searchParams.get('endDate') ? new Date(searchParams.get('endDate')!) : undefined;

    const result = await getAuditLogs({
      page,
      limit,
      userId,
      action,
      resource,
      startDate,
      endDate
    });

    // Handle PDF export
    if (isExport && format === 'pdf') {
      const doc = new PDFDocument({ size: 'A4', margin: 50 });
      const buffers: Buffer[] = [];
      
      doc.on('data', buffers.push.bind(buffers));
      doc.on('end', () => {});

      // Header
      doc
        .fontSize(20)
        .text('Audit Logs Report', { align: 'center' })
        .moveDown();

      // Report metadata
      doc.fontSize(10);
      doc.text(`Generated: ${new Date().toLocaleString()}`, { align: 'left' });
      if (startDate) doc.text(`Start Date: ${new Date(startDate).toLocaleDateString()}`);
      if (endDate) doc.text(`End Date: ${new Date(endDate).toLocaleDateString()}`);
      if (action && action !== 'all') doc.text(`Action Filter: ${action}`);
      if (resource && resource !== 'all') doc.text(`Resource Filter: ${resource}`);
      doc.text(`Total Logs: ${result.logs.length}`, { align: 'left' });
      doc.moveDown(2);

      // Table header
      const tableTop = doc.y;
      doc.fontSize(10);
      doc.font('Helvetica-Bold');
      doc.text('Timestamp', 50, tableTop);
      doc.text('User', 150, tableTop);
      doc.text('Action', 280, tableTop);
      doc.text('Resource', 380, tableTop);
      doc.text('Details', 450, tableTop);
      doc.y += 10;
      doc.moveTo(50, doc.y).lineTo(550, doc.y).stroke();
      doc.y += 5;
      doc.font('Helvetica');

      // Table rows
      let currentY = doc.y;
      const rowHeight = 30;
      const pageHeight = 750;
      
      result.logs.forEach((log: any, index: number) => {
        // Check if we need a new page
        if (currentY > pageHeight) {
          doc.addPage();
          currentY = 50;
        }

        const logDate = new Date(log.createdAt).toLocaleString();
        const userName = log.user?.name || log.user?.email || 'Unknown';
        const actionText = log.action.replace(/_/g, ' ').toLowerCase();
        const resourceText = log.resource || 'N/A';
        
        // Format details
        let detailsText = 'No details';
        if (log.details) {
          if (typeof log.details === 'object') {
            detailsText = JSON.stringify(log.details).substring(0, 50) + '...';
          } else {
            detailsText = String(log.details).substring(0, 50);
          }
        }

        // Draw row
        doc.fontSize(8);
        doc.text(logDate.substring(0, 18), 50, currentY, { width: 90, ellipsis: true });
        doc.text(userName.substring(0, 20), 150, currentY, { width: 120, ellipsis: true });
        doc.text(actionText.substring(0, 15), 280, currentY, { width: 90, ellipsis: true });
        doc.text(resourceText.substring(0, 10), 380, currentY, { width: 60, ellipsis: true });
        doc.text(detailsText, 450, currentY, { width: 100, ellipsis: true });
        
        currentY += rowHeight;
        doc.y = currentY;
        
        // Draw row separator
        if (index < result.logs.length - 1) {
          doc.moveTo(50, currentY - 5).lineTo(550, currentY - 5).stroke();
        }
      });

      // Footer
      doc.fontSize(8);
      doc.text(
        `Page 1 of 1 | Generated by ${session.user.email || 'Admin'}`,
        50,
        pageHeight - 20,
        { align: 'center', width: 500 }
      );

      doc.end();

      const pdfBuffer = Buffer.concat(buffers);

      return new NextResponse(pdfBuffer, {
        headers: {
          'Content-Type': 'application/pdf',
          'Content-Disposition': `attachment; filename="audit-logs-${new Date().toISOString().split('T')[0]}.pdf"`,
        },
      });
    }

    // Handle CSV export (keep existing functionality)
    if (isExport && format === 'csv') {
      const csvRows = [
        ['Timestamp', 'User', 'Email', 'Action', 'Resource', 'Resource ID', 'IP Address', 'User Agent', 'Details'].join(',')
      ];

      result.logs.forEach((log: any) => {
        const row = [
          new Date(log.createdAt).toISOString(),
          `"${(log.user?.name || '').replace(/"/g, '""')}"`,
          `"${(log.user?.email || '').replace(/"/g, '""')}"`,
          `"${log.action.replace(/"/g, '""')}"`,
          `"${(log.resource || '').replace(/"/g, '""')}"`,
          `"${(log.resourceId || '').replace(/"/g, '""')}"`,
          `"${(log.ipAddress || '').replace(/"/g, '""')}"`,
          `"${(log.userAgent || '').replace(/"/g, '""')}"`,
          `"${(typeof log.details === 'object' ? JSON.stringify(log.details) : String(log.details || '')).replace(/"/g, '""')}"`
        ];
        csvRows.push(row.join(','));
      });

      return new NextResponse(csvRows.join('\n'), {
        headers: {
          'Content-Type': 'text/csv',
          'Content-Disposition': `attachment; filename="audit-logs-${new Date().toISOString().split('T')[0]}.csv"`,
        },
      });
    }

    // Default: return JSON
    return NextResponse.json(result);

  } catch (error) {
    console.error('Error fetching audit logs:', error);
    return NextResponse.json(
      { error: 'Failed to fetch audit logs' },
      { status: 500 }
    );
  }
}